# Leksička analiza

## Deterministički konačni automati (DKA)
- Predstavljanje DKA pomoću <ins>**grafa prelaza**</ins> na osnovu zadate <ins>**tabele prelaza**</ins> i obrnuto
- Navođenje sekvenci ulaznih simbola koje zadati DKA <ins>**prihvata**</ins>, kao i sekvenci koje taj DKA <ins>**odbija**</ins>
- <ins>**Određivanje najkraće sekvence**</ins> ulaznih simbola koju DKA prihvata (određuje se tako što se krene od svih stanja prihvatanja pa se rekonstruišu putanje kroz stanja unazad dok se ne dođe do startnog stanja, pri čemu se u tom postupku odsecaju putanje za koje se zaključi da sigurno ne mogu biti najkraće)
- <ins>**Konstrukcija DKA tako da prihvata zadate sekvence**</ins> ulaznih simbola, dati su i svi mogući ulazni simboli, tj. ulazna azbuka
- <ins>**Dokaz da su dva stanja DKA ekvivalentna**</ins> ispitivanjem <ins>**uslova kompatibilnosti i propagacije**</ins> za ta dva stanja (uslov kompatibilnosti je ispunjen ako su oba stanja prihvatanja ili ako su oba stanja odbijanja, a uslov propagacije je ispunjen ako se iz oba stanja za iste ulazne simbole prelazi u međusobno kompatibilna stanja)
- <ins>**Dokaz da su cela dva DKA ekvivalentna**</ins> ispitivanjem <ins>**uslova kompatibilnosti i propagacije**</ins> za svaki par stanja tih DKA počevši od startnih stanja oba DKA i konzumiranjem ulaznih simbola dokle god neki od narednih parova stanja nije već ispitan
- <ins>**Dokaz da neko stanje prvog DKA nije ekvivalentno**</ins> ni sa jednim drugim stanjem drugog DKA ispitivanjem <ins>**uslova kompatibilnosti i propagacije**</ins> za to stanje prvog DKA i sva ostala stanja drugog DKA
- <ins>**Smišljanje primera dva ekvivalentna DKA**</ins> sa sledećim osobinama:
    1. više ekvivalentnih stanja prvog DKA je ekvivalentno sa jednim stanjem drugog DKA
    2. prvi DKA takođe treba da ima stanje koje nije ekvivalentno ni sa jednim stanjem drugog DKA (da bi oba DKA i dalje bila ekvivalentna, samo je suština da takvo stanje bude nedostižno u prvom DKA, pa samim tim neće uticati na rad tog DKA i oba DKA će i dalje biti ekvivalentna jer će im funkcionisanje i dalje biti isto)
- <ins>**Minimizacija DKA**</ins>:
    1. uklanjanjem <ins>**nedostižnih stanja**</ins> (nedostižna stanja su ona do kojih je nemoguće doći počevši od startnog stanja DKA i konzumiranjem bilo kakve sekvence ulaznih simbola - određuju se tako što se odredi skup svih dostižnih stanja počevši od startnog stanja DKA, pa su onda nedostižna stanja DKA sva stanja koja se ne nađu u tom skupu)
    2. zamenom svih međusobno <ins>**ekvivalentnih stanja**</ins> jednim stanjem (ekvivalentna stanja su ona za koje su ispunjeni <ins>**uslovi kompatibilnosti i propagacije**</ins> - mogu da se odrede tako što će se porediti svaka dva stanja iz različitih DKA međusobno, a može se iskoristiti i optimalniji postupak u kome bismo postepeno smanjivali skupove ekvivalentnih stanja dokle god ima izmena u tim skupovima za neke ulazne simbole)

## Nedeterministički konačni automati (NKA)
- Utvrđivanje da li NKA za koji je data tabela prelaza <ins>**prihvata**</ins> zadatu sekvencu ulaznih simbola (kod NKA sekvenca ulaznih simbola se prihvata ako postoji bar jedna putanja u NKA koja se završava u stanju prihvatanja za tu sekvencu)
    - Ovo se radi tako što se krene od skupa startnih stanja i pri konzumiranju trenutnog ulaznog simbola se definiše naredni skup mogućih stanja tako što se uzmu u obzir prelazi za sva stanja iz trenutnog skupa stanja - nakon procesiranja cele sekvence ulaznih simbola, ukoliko postoji bar jedno stanje u finalnom skupu stanja koje je stanje prihvatanja, sekvenca se prihvata jer to znači da postoji bar jedna putanja u NKA za koju se završava u stanju prihvatanja, u suprotnom se odbija
- Ukoliko za istu sekvencu ulaznih simbola postoji više različitih putanja u NKA po kojima se ta sekvenca prihvata, potrebno je definisati <ins>**prioritete**</ins> kako bi se znalo koja putanja će se odabrati (u projektu je to npr. situacija poklapanja ključnih reči i identifikatora, tu smo razrešili ovu situaciju navodeći ključne reči pre identifikatora u `lexer.flex` fajlu, pa smo time precizirali da su te putanje prioritetnije)
- <ins>**Konverzija NKA u DKA**</ins>
    - Krene se od skupa startnih stanja i za svaki ulazni simbol se definiše naredni skup stanja tako što se prvo za svako stanje iz trenutnog skupa stanja dodaju stanja dostižna konzumiranjem ulaznog simbola, a zatim i ona stanja dostižna `epsilon` prelazima (bez konzumiranja ulaznog simbola) uključujući i dodata stanja, a postupak se ponavlja dokle god se formira neki novi skup stanja - kada nema više novih skupova stanja postupak je gotov i svaki skup stanja iz NKA predstavlja po jedno stanje DKA
    - Ukoliko je bar jedno stanje u skupu stanja stanje prihvatanja, onda je to stanje DKA stanje prihvatanja, u suprotnom je stanje odbijanja
- Data su dva DKA i neka prvi DKA prihvata sekvencu ulaznih simbola `s1`, a drugi DKA sekvencu ulaznih simbola `s2`, treba <ins>**konstruisati minimalni DKA koji prihvata sekvence ulaznih simbola**</ins> `s1s2`
    1. Prvo treba konstruisati NKA koji će prihvatati sekvence ulaznih simbola `s1s2` spajanjem informacija iz oba DKA (ovde uvek treba obratiti pažnju da li su sekvence poništive, npr. u konkretnom primeru s vežbi je prvi DKA prihvatao praznu sekvencu, što znači da je moguće da za sekvencu `s1s2` startno stanje bude i startno stanje drugog DKA; zatim, u prelaze iz prvog DKA u kojima se prelazi u stanja prihvatanja prvog DKA treba dodati i prelaz u startno stanje drugog DKA zato što je u tim trenucima prepoznata sekvenca `s1` i može se preći na prepoznavanje sekvence `s2` da bi se prepoznala sekvenca `s1s2`)
    2. Zatim treba uraditi <ins>**konverziju NKA u DKA**</ins>
    3. Na kraju treba još <ins>**minimizovati DKA**</ins>

## Regularni izrazi
- <ins>**Smišljanje regularnog izraza**</ins> koji opisuje označene decimalne konstante, dati su primeri validnih označenih decimalnih konstanti i mi treba na osnovu njih da napišemo regularni izraz
- <ins>**Tompsonov algoritam**</ins> (za konverziju regularnog izraza u NKA)
    - Po potrebi izdelimo regularni izraz u delove koji su konkatenirani i za svaki deo nacrtamo grafa prelaza i na taj način ćemo konstruisati NKA za ceo regularni izraz spajanjem tih delova
    - Cela suština <ins>**Tompsonovog algoritma**</ins> je dodavanje `epsilon` prelaza tamo gde je potrebno kako bi se regularni izrazi uspešno predstavili preko NKA; nije obavezno da se nužno ispoštuje Tompsonov algoritam što se tiče `epsilon` prelaza jer često ima mnogo suvišnih `epsilon` prelaza, slobodno možemo da to optimizujemo ali treba paziti da se ne ukloni više `epsilon` prelaza nego što bi smelo - da bismo bili sigurni da to nismo uradili, uvek možemo to proveriti tako što proverimo sve putanje u grafu prelaza i vidimo da li se za različite ulazne simbole one razlikuju, tj. da li se sastoje od različitog skupa stanja, ako da onda je sve u redu
    - Dalje se obično traži <ins>**konverzija NKA u DKA**</ins>, i zatim <ins>**minimizacija DKA**</ins>
- <ins>**Metod pozicija**</ins> (za konverziju regularnog izraza u DKA)
    1. Obavezno dodati <ins>**simbol za kraj regularnog izraza**</ins> (oboreno slovo T na desno)
    2. Konstruisati <ins>**sintaksno stablo**</ins> na osnovu regularnog izraza, pri čemu će listovi stabla biti ulazni simboli, a unutrašnji čvorovi stabla mogu biti <ins>**čvorovi konkatenacije**</ins>, <ins>**čvorovi unije**</ins>, <ins>**čvorovi zvezdastog zatvaranja**</ins> ili <ins>**čvorovi pozitivnog zatvaranja**</ins>
    3. Odrediti sve <ins>**poništive čvorove**</ins> u stablu i zaokružiti ih (čvor konkatenacije je poništiv ako su oba njegova naslednika poništiva, čvor unije je poništiv ako je bar jedan od njegovih naslednika poništiv, čvor zvezdastog zatvaranja je uvek poništiv, obratiti takođe pažnju na podstabla u kojima se `epsilon` nalazi u listu, npr. ako je koren tog podstabla čvor unije, taj čvor će biti poništiv ako je jedan od naslednika `epsilon`)
    4. Obići stablo u <ins>**postorder**</ins> poretku i dodeliti numeričke <ins>**pozicije**</ins> listovima redom kako se obilaze počevši od broja 1 (`epsilon` listovima se <ins>**ne dodeljuju pozicije**</ins> jer to nisu nikakvi ulazni simboli, pozicije dodeljujemo samo ulaznim simbolima i listu u kome je znak za kraj regularnog izraza)
    5. Ponovo obići stablo u <ins>**postorder**</ins> poretku i odrediti za svaki čvor <ins>**skup prvih pozicija**</ins>, tj. skup listova za podstablo od datog čvora koji se mogu prvi obići u tom podstablu, ovo je vrlo intuitivno uraditi, samo treba paziti na poništive čvorove i na tip čvora (konkatenacija, unija ili zvezdasto zatvaranje) koji je koren podstabla
    6. Ponovo obići stablo u <ins>**postorder**</ins> poretku i odrediti za svaki čvor <ins>**skup poslednjih pozicija**</ins>, tj. skup listova za podstablo od datog čvora koji se mogu poslednji obići u tom podstablu, ovo je vrlo intuitivno uraditi, samo treba paziti na poništive čvorove i na tip čvora (konkatenacija, unija ili zvezdasto zatvaranje) koji je koren podstabla
    7. Ponovo obići stablo u <ins>**postorder**</ins> poretku i uzeti u razmatranje svaki <ins>**čvor konkatenacije**</ins>, <ins>**čvor zvezdastog zatvaranja**</ins> i <ins>**čvor pozitivnog zatvaranja**</ins> (čvorovi unije se ne razmatraju zato što se kod njih bira uvek samo jedan naslednik i nikada se ne može desiti da nakon jednog naslednika dođe neki drugi naslednik) i ažurirati <ins>**skupove sledećih pozicija**</ins> za svaku poziciju - kod <ins>**čvora konkatenacije**</ins> za svaku poziciju iz skupa poslednjih pozicija njegovog levog naslednika možemo dodati u njen skup sledećih pozicija sve pozicije iz skupa prvih pozicija njegovog desnog naslednika, a kod <ins>**čvora zvezdastog zatvaranja**</ins> i kod <ins>**čvora pozitivnog zatvaranja**</ins> za svaku poziciju iz skupa poslednjih pozicija njegovog naslednika možemo dodati u njen skup sledećih pozicija sve pozicije iz skupa prvih pozicija tog istog naslednika
    8. Konstruisati <ins>**tabelu prelaza za DKA**</ins> služeći se skupovima sledećih pozicija, za <ins>**startno stanje**</ins> uzeti skup prvih pozicija od korena sintaksnog stabla, <ins>**stanja prihvatanja**</ins> će biti ona koja sadrže u svom skupu stanja simbol za kraj regularnog izraza
    9. Ako se u regularnom izrazu <ins>**više puta javljaju isti ulazni simboli**</ins>, tada tabela prelaza za DKA treba da se na kraju samo <ins>**dodatno transformiše**</ins> tako da se kolone za sve pozicije koje se odnose na isti ulazni simbol spoje u jednu kolonu, radi se unija svih prelaza iz svih kolona u svakom redu, pa se tako dobijaju prelazi za finalnu kolonu u svakom redu
    10. <ins>**Minimizovati DKA**</ins>


## Konačni procesori
- <ins>**Konačni procesori**</ins> su zapravo konačni automati u kojima se mogu dodati <ins>**proizvoljne akcije**</ins> koje treba da se izvrše <ins>**pri odgovarajućim prelazima**</ins> (identičan koncept kao <ins>**Milijeva mreža**</ins> koja je rađena na predmetu ORT1) ili <ins>**u odgovarajućim stanjima**</ins> (identičan koncept kao <ins>**Murova mreža**</ins> koja je rađena na predmetu ORT1)
- Proces <ins>**transliteracije**</ins> predstavlja grupisanje više različitih ulaznih sekvenci za koje <ins>**konačni procesor**</ins> ima isto ponašanje u jednu istu klasu radi pojednostavljenja definisanja konačnog procesora (npr. sve moguće cifre transliterator može da grupiše u jednu istu klasu `DIGIT`, i onda ta klasa da se koristi kao ulazni simbol u tabeli prelaza konačnog procesora; naravno, klasa `DIGIT` će imati nekakav atribut u kome će se čuvati vrednost same cifre, tako da se može to zamisliti da se za svaku cifru kreira objekat klase `DIGIT`, a pri konstrukciji konačnog procesora se samo koristi `DIGIT` kao ulazni simbol umesto da se kreiraju zasebne kolone za svaku cifru)
- <ins>**Transliterator**</ins> može efikasno da se implementira kao vektor tako što možemo vektor logički da podelimo u sekcije pri čemu bi svaka sekcija pripadala zasebnoj klasi, a svaki element vektora unutar sekcije se odnosi na specifičnu vrednost koju može da ima objekat te klase (npr. imamo vektor od 36 elemenata, prvih 10 elemenata su posvećeni klasi `DIGIT` čiji objekti mogu imati vrednost neke od cifara `[0-9]`, a ostalih 26 elemenata su posvećeni klasi `CHARACTER` čiji objekti mogu imati vrednost nekog slova engleskog alfabeta `[a-z]`)
- Konstrukcija konačnog procesora:
    1. Odraditi postupak <ins>**transliteracije**</ins> radi jednostavnije tabele prelaza
    2. <ins>**Konstruisati tabelu prelaza za DKA**</ins>, pri čemu stanja i prelaze treba osmisliti u zavisnosti od toga kakve sekvence treba prepoznati (pogodno je svako stanje opisati ukratko da bismo kasnije mogli da zaključimo u kojim prelazima treba izvršiti koje akcije da bi se postiglo šta se traži da konačni procesor uradi)
    3. <ins>**Definisati sve potrebne akcije za odgovarajuće prelaze ili stanja**</ins> (ukoliko je potrebno npr. definisati akcije za prelaze u stanje 1, a postoji više prelaza u stanje 1, možemo ih razlikovati tako što ćemo umesto 1 na svim mestima u tabeli prelaza pisati redom 1a, 1b, 1c itd. i onda za svaki takav prelaz možemo definisati različitu akciju ukoliko je to potrebno; možemo i dodati kolonu za koju je ulazni simbol znak za kraj regularnog izraza  (oboreno slovo T na desno) i da onda tu definišemo npr. šta treba uraditi u odgovarajućim stanjima prihvatanja ili odbijanja kada se dođe do kraja regularnog izraza)

## Programska implementacija konačnog automata stanja
- <ins>**Proceduralna eksplicitna implementacija**</ins> (koristeći eksplicitno definisanu matricu koja predstavlja tabelu prelaza konačnog automata; stanja se predstavljaju pomoću `enum` strukture)
- <ins>**Proceduralna implicitna implementacija**</ins> (bez eksplicitno definisane matrice koja bi predstavljala tabelu prelaza konačnog automata, svi prelazi obrađeni isključivo kontrolnim strukturama u kodu, pa je na taj način implicitno definisana tabela prelaza konačnog automata; stanja se predstavljaju pomoću `enum` strukture)
- <ins>**Objektno orijentisana implementacija**</ins> (primena stanja, projektnog šablona - svako stanje je predstavljeno zasebnom konkretnom klasom, a sve konkretne klase stanja su izvedene iz iste apstraktne klase i definišu metodu za prelazak u naredno stanje iz tog stanja za trenutni ulazni simbol)
-  <ins>**Ne zaboraviti**</ins> da se doda prelaz u stanje greške ukoliko se na ulazu detektuje simbol koji se uopšte ne nalazi u skupu dozvoljenih simbola, ove situacije nismo obrađivali radeći zadatke, samo smo definisali prelaze pri detekciji validnih ulaznih simbola

<hr><br><br>

# Sintaksna analiza

## Gramatike
- Zadati su sekvenca terminala i gramatika, treba prvo odrediti <ins>**da li je sekvenca podržana od strane gramatike**</ins>, i samo ako jeste, onda sprovesti <ins>**levo izvođenje**</ins> (primenjivanje smena s leva na desno), <ins>**desno izvođenje**</ins> (primenjivanje smena s desna na levo) i nacrtati <ins>**stablo izvođenja**</ins>
- <ins>**Izbacivanje suvišnih neterminala**</ins> iz gramatike (važno je da se prvo uklone mrtvi neterminali pa tek onda nedostižni - ako bismo uradili obrnutim redosledom, možemo ostaviti u gramatici žive neterminale koji su bili dostižni samo iz mrtvih neterminala, a oni neće biti dostižni nakon uklanjanja mrtvih neterminala):
    1. uklanjanjem <ins>**mrtvih neterminala**</ins> (mrtvi neterminali su oni koji primenjivanjem smena iz gramatike nikada ne mogu da terminiraju, tj. da se zamene skupom terminala; <ins>**odredimo sve žive neterminale počevši od onih koji imaju smene sačinjene isključivo od terminala, oni koji na kraju preostanu su mrtvi**</ins>) - ukloniti sve smene iz gramatike u kojima se nalaze mrtvi neterminali bilo sa leve ili desne strane smene
    2. uklanjanjem <ins>**nedostižnih neterminala**</ins> (nedostižni neterminali su oni do kojih se nikada ne može doći počevši od startnog neterminala gramatike i primenom bilo koje kombinacije smena te gramatike; <ins>**odredimo sve dostižne neterminale počevši od startnog neterminala, oni koji na kraju preostanu su nedostižni**</ins>) - ukloniti sve smene iz gramatike u kojima se nalaze nedostižni neterminali bilo sa leve ili desne strane smene
- <ins>**Konstruisati desno-linearnu gramatiku na osnovu datog NKA**</ins>, a zatim ukloniti suvišne neterminale iz te gramatike
    1. Ulazni simboli NKA će biti terminali gramatike
    2. Stanja NKA će biti neterminali gramatike (proizvoljnom stanju NKA `A` odgovara neterminal `<A>`), a startno stanje NKA će biti startni neterminal gramatike
    3. Proizvoljnom prelazu NKA iz stanja `A` u stanje `B` za ulazni simbol `x` odgovara smena `<A> -> x<B>`
    4. Proizvoljno stanje NKA `A` koje je stanje prihvatanja zahteva dodatnu smenu u gramatici `<A> -> epsilon`
- <ins>**Transformisati datu desno-linearnu gramatiku u regularnu gramatiku**</ins> (regularne gramatike su podskupovi desno-linearnih gramatika)
    1. Smene tipa `<A> -> <B>` nisu dozvoljene u regularnim gramatikama, a jesu u desno-linearnim gramatikama - treba ih ukloniti tako što će se umesto njih u gramatiku ubaciti nove smene u kojima se neterminal `<A>` direktno smenjuje svim mogućim smenama neterminala `<B>` (npr. ako su smene za neterminal `<B>` ove `<B> -> x; <B> -> y;`, onda treba smenu `<A> -> <B>` zameniti smenama `<A> -> x; <A> -> y;`)
    2. Smene tipa `<A> -> xyz<B>` nisu dozvoljene u regularnim gramatikama, a jesu u desno-linearnim gramatikama - treba ih ukloniti tako što će se umesto njih uvesti nove smene (za ovaj konkretan primer bi trebalo smenu `<A> -> xyz<B>`  zameniti smenama `<A> -> x<yzB>; <yzB> -> y<zB>; <zB> -> z<B>;`)
    3. Smene tipa `<A> -> xyz` nisu dozvoljene u regularnim gramatikama, a jesu u desno-linearnim gramatikama - treba ih ukloniti tako što će se uvesti nova smena `<epsilon> -> epsilon`, a smene tipa `<A> -> xyz` zameniti sa `<A> -> xyz<epsilon>`
- <ins>**Konstruisati NKA na osnovu date regularne gramatike**</ins> (inverzan postupak u odnosu na konstruisanje regularne gramatike na osnovu datog NKA - taj postupak je već detaljno opisan iznad):
    1. Terminali gramatike će biti ulazni simboli NKA
    2. Neterminali gramatike će biti stanja NKA (proizvoljnom neterminalu gramatike `<A>` odgovara stanje NKA `A`), a startni neterminal gramatike će biti startno stanje NKA
    3. Proizvoljnoj smeni `<A> -> x<B>` odgovara prelaz NKA iz stanja `A` u stanje `B` za ulazni simbol `x`
    4. Proizvoljna smena u gramatici `<A> -> epsilon` govori da je stanje NKA `A` stanje prihvatanja 

## Potisni automati